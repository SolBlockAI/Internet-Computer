use ic_crypto_ecdsa_secp256k1::{KeyDecodingError, PrivateKey, PublicKey};
use ic_crypto_test_utils_reproducible_rng::reproducible_rng;

#[test]
fn should_pass_wycheproof_ecdsa_secp256k1_verification_tests() -> Result<(), KeyDecodingError> {
    use wycheproof::ecdsa::*;

    let test_set =
        TestSet::load(TestName::EcdsaSecp256k1Sha256P1363).expect("Unable to load test set");

    for test_group in &test_set.test_groups {
        let pk = PublicKey::deserialize_sec1(&test_group.key.key)?;
        let pk_der = PublicKey::deserialize_der(&test_group.der)?;
        assert_eq!(pk, pk_der);

        for test in &test_group.tests {
            // The Wycheproof ECDSA tests do not normalize s so we must use
            // the verification method that accepts either valid s
            let accepted = pk.verify_signature_with_malleability(&test.msg, &test.sig);
            assert_eq!(accepted, test.result == wycheproof::TestResult::Valid);
        }
    }

    Ok(())
}

#[test]
fn test_sign_prehash_works_with_any_size_input_gte_16() {
    let mut rng = reproducible_rng();

    let sk = PrivateKey::generate_using_rng(&mut rng);
    let pk = sk.public_key();

    for i in 0..16 {
        let buf = vec![0x42; i];
        assert_eq!(sk.sign_digest(&buf), None);
    }

    for i in 16..1024 {
        let buf = vec![0x42; i];
        let sig = sk.sign_digest(&buf).unwrap();
        assert!(pk.verify_signature_prehashed(&buf, &sig));
    }
}

#[test]
fn should_use_rfc6979_nonces_for_ecdsa_signature_generation() {
    // Unfortunately RFC 6979 does not include tests for secp256k1. This
    // signature was instead generated by another implementation that both supports
    // secp256k1 ECDSA and uses RFC 6979 nonce generation.

    let sk = PrivateKey::deserialize_sec1(
        &hex::decode("8f44c8e5da21a3e2933fbf732519a604891b4731f19045f078e6ce57893c1f2a")
            .expect("Valid hex"),
    )
    .expect("Valid key");

    let message = b"abc";
    let expected_sig = "d8bdb0ddfc8ebb8be42649048e92edc8547d1587b2a8f721738a2ecc0733401c70e86d3042ebbb50dccfbfbdf6c0462c7be45bcd0208d33e34efec273a86eab9";

    let generated_sig = sk.sign_message(message);
    assert_eq!(hex::encode(generated_sig), expected_sig);

    // Now check the prehash variant:
    let message_hash = ic_crypto_sha2::Sha256::hash(message);
    let generated_sig = sk.sign_digest(&message_hash).unwrap();
    assert_eq!(hex::encode(generated_sig), expected_sig);
}

#[test]
fn should_reject_short_x_when_deserializing_private_key() {
    for short_len in 0..31 {
        let short_x = vec![42; short_len];
        assert!(PrivateKey::deserialize_sec1(&short_x).is_err());
    }
}

#[test]
fn should_reject_long_x_when_deserializing_private_key() {
    for long_len in 33..128 {
        let long_x = vec![42; long_len];
        assert!(PrivateKey::deserialize_sec1(&long_x).is_err());
    }
}

#[test]
fn should_accept_signatures_that_we_generate() {
    use rand::RngCore;

    let mut rng = reproducible_rng();

    let sk = PrivateKey::generate_using_rng(&mut rng);
    let pk = sk.public_key();

    for m in 0..100 {
        let mut msg = vec![0u8; m];
        rng.fill_bytes(&mut msg);
        let sig = sk.sign_message(&msg);

        assert_eq!(
            sk.sign_message(&msg),
            sig,
            "ECDSA signature generation is deterministic"
        );

        assert!(pk.verify_signature(&msg, &sig));
        assert!(pk.verify_signature_with_malleability(&msg, &sig));
    }
}

#[test]
fn should_reject_high_s_in_signature_unless_malleable() -> Result<(), KeyDecodingError> {
    let pk = PublicKey::deserialize_sec1(&hex::decode("04E38257CE81AB62AB1DF591E360AB0021D2D24E737299CF48317DBF31A3996A2A78DD07EA1996F24FE829B4EE968BA2700632D8F165E793E41AE37B8911FC83C9").unwrap())?;
    let msg = b"test";
    let sig = hex::decode("6471F8E5E63D6055AA6F6D3A8EBF49935D1316D6A54B9B09465B3BEB38E3AC14CE0FFBABD8E3248BEEBD568DCBCC7861126B1AB88E721D0206E9D67ECD878C7C").unwrap();

    assert!(!pk.verify_signature(msg, &sig));
    assert!(pk.verify_signature_with_malleability(msg, &sig));

    // Test again using the pre-hashed variants:
    let msg_hash = ic_crypto_sha2::Sha256::hash(msg);

    assert!(!pk.verify_signature_prehashed(&msg_hash, &sig));
    assert!(pk.verify_signature_prehashed_with_malleability(&msg_hash, &sig));

    Ok(())
}

#[test]
fn should_serialization_and_deserialization_round_trip_for_private_keys(
) -> Result<(), KeyDecodingError> {
    let mut rng = reproducible_rng();

    for _ in 0..200 {
        let key = PrivateKey::generate_using_rng(&mut rng);

        let key_via_sec1 = PrivateKey::deserialize_sec1(&key.serialize_sec1())?;
        let key_via_5915_der = PrivateKey::deserialize_rfc5915_der(&key.serialize_rfc5915_der())?;
        let key_via_5915_pem = PrivateKey::deserialize_rfc5915_pem(&key.serialize_rfc5915_pem())?;
        let key_via_p8_der = PrivateKey::deserialize_pkcs8_der(&key.serialize_pkcs8_der())?;
        let key_via_p8_pem = PrivateKey::deserialize_pkcs8_pem(&key.serialize_pkcs8_pem())?;

        let expected = key.serialize_sec1();
        assert_eq!(expected.len(), 32);

        assert_eq!(key_via_sec1.serialize_sec1(), expected);
        assert_eq!(key_via_5915_der.serialize_sec1(), expected);
        assert_eq!(key_via_5915_pem.serialize_sec1(), expected);
        assert_eq!(key_via_p8_der.serialize_sec1(), expected);
        assert_eq!(key_via_p8_pem.serialize_sec1(), expected);
    }
    Ok(())
}

#[test]
fn should_serialization_and_deserialization_round_trip_for_public_keys(
) -> Result<(), KeyDecodingError> {
    let mut rng = reproducible_rng();

    for _ in 0..2000 {
        let key = PrivateKey::generate_using_rng(&mut rng).public_key();

        let key_via_sec1 = PublicKey::deserialize_sec1(&key.serialize_sec1(false))?;
        let key_via_sec1c = PublicKey::deserialize_sec1(&key.serialize_sec1(true))?;
        let key_via_der = PublicKey::deserialize_der(&key.serialize_der())?;
        let key_via_pem = PublicKey::deserialize_pem(&key.serialize_pem())?;

        assert_eq!(key.serialize_sec1(true).len(), 33);
        let expected = key.serialize_sec1(false);
        assert_eq!(expected.len(), 65);

        assert_eq!(key_via_sec1.serialize_sec1(false), expected);
        assert_eq!(key_via_sec1c.serialize_sec1(false), expected);
        assert_eq!(key_via_der.serialize_sec1(false), expected);
        assert_eq!(key_via_pem.serialize_sec1(false), expected);
    }

    Ok(())
}

#[test]
fn should_be_able_to_parse_openssl_rfc5915_format_key() {
    pub const SAMPLE_SECP256K1_PEM: &str = r#"-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIJQhkGfs2ep0VGU5BgJvcc4NVWG0GCc+aqkH7b3DL6aZoAcGBSuBBAAK
oUQDQgAENBexvaA6VKI60UxeTDHiocVBcf+y/irJOHzvQSlwiZM3MCDu6lxaP/Bw
i389XZmdlKFbsLkUI9dDQgMP98YnUA==
-----END EC PRIVATE KEY-----
"#;

    let key = PrivateKey::deserialize_rfc5915_pem(SAMPLE_SECP256K1_PEM).unwrap();

    assert_eq!(
        hex::encode(key.serialize_sec1()),
        "94219067ecd9ea7454653906026f71ce0d5561b418273e6aa907edbdc32fa699"
    );

    // Our re-encoding includes carriage returns, ignore that:
    assert_eq!(
        key.serialize_rfc5915_pem().replace('\r', ""),
        SAMPLE_SECP256K1_PEM
    );
}

mod try_recovery_from_digest {
    use ic_crypto_ecdsa_secp256k1::{PrivateKey, PublicKey, RecoveryError};
    use ic_crypto_test_utils_reproducible_rng::reproducible_rng;
    use k256::ecdsa::{Signature, VerifyingKey};
    use rand::Rng;

    #[test]
    fn should_fail_when_signature_not_parsable() {
        let mut rng = reproducible_rng();
        let public_key = PrivateKey::generate_using_rng(&mut rng).public_key();

        let recid = public_key.try_recovery_from_digest(&[0], &[0_u8; 64]);

        assert_eq!(
            recid,
            Err(RecoveryError::SignatureParseError(
                "signature error".to_string()
            ))
        );
    }

    #[test]
    fn should_recover_public_key_from_y_parity() {
        let mut rng = reproducible_rng();
        let private_key = PrivateKey::generate_using_rng(&mut rng);
        let public_key = private_key.public_key();
        let digest = rng.gen::<[u8; 32]>();
        let signature = private_key
            .sign_digest(&digest)
            .expect("cannot fail because digest > 16 bytes");

        let recid = public_key
            .try_recovery_from_digest(&digest, &signature)
            .expect("cannot fail because params are correct");

        let recovered_public_key = VerifyingKey::recover_from_prehash(
            &digest,
            &Signature::from_slice(&signature).expect("valid signature"),
            k256::ecdsa::RecoveryId::from_byte(recid.to_byte()).expect("valid recovery id"),
        )
        .expect("cannot fail because params are correct");

        assert_eq!(
            public_key.serialize_sec1(false),
            recovered_public_key
                .to_encoded_point(false)
                .as_bytes()
                .to_vec()
        );
    }

    #[test]
    fn should_compute_signature_y_parity_on_eth_transaction() {
        //https://sepolia.etherscan.io/tx/0x66a9a218ea720ac6d2c9e56f7e44836c1541c186b7627bda220857ce34e2df7f
        let public_key = "040b6fb17608bd3389242d3746988c6e45e89387ba80862414052a7893422397d63d52f93565eb26aebfc1d83e4d6d9fcedf08d04c91709c10d8703bfd1514811e";
        let unsigned_tx_hash = "0x2d9e6453d9864cff7453ca35dcab86be744c641ba4891c2fe9aeaa2f767b9758";
        let r = "0x7d097b81dc8bf5ad313f8d6656146d4723d0e6bb3fb35f1a709e6a3d4426c0f3";
        let s = "0x4f8a618d959e7d96e19156f0f5f2ed321b34e2004a0c8fdb7f02bc7d08b74441";
        let expected_v = true;

        let public_key =
            PublicKey::deserialize_sec1(&hex::decode(public_key).expect("valid hex string"))
                .expect("valid public key");
        let digest = hex::decode(&unsigned_tx_hash[2..]).expect("valid hex string");
        let signature = [
            hex::decode(&r[2..]).expect("valid hex string"),
            hex::decode(&s[2..]).expect("valid hex string"),
        ]
        .concat();

        let recid = public_key
            .try_recovery_from_digest(&digest, &signature)
            .expect("valid signature");

        assert_eq!(recid.is_y_odd(), expected_v);
        assert!(!recid.is_x_reduced());
    }
}
